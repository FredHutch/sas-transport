///////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2025 Fred Hutch Cancer Center
// Licensed under the MIT License - see LICENSE file for details
///////////////////////////////////////////////////////////////////////////////
package org.scharp.sas_transport;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertInstanceOf;
import static org.junit.jupiter.api.Assertions.assertThrows;

/**
 * Unit tests for the {@link DoubleConverter} class.
 */
public class DoubleConverterTest {

    private void runDoubleToXportTest(double number, int[] expectedXport) {
        byte[] actualXport = DoubleConverter.doubleToXport(number);
        assertEquals(actualXport.length, expectedXport.length);
        for (int i = 0; i < expectedXport.length; i++) {
            assertEquals((byte) expectedXport[i], actualXport[i], i + "th index is incorrect");
        }
    }

    private static void runIllegalArgumentDoubleToXportTest(double number, String expectedExceptionMessage) {
        Exception exception = assertThrows( //
            IllegalArgumentException.class, //
            () -> DoubleConverter.doubleToXport(number), //
            "DoubleConverter.doubleToXport on illegal number");
        assertEquals(expectedExceptionMessage, exception.getMessage());
    }

    @Test
    public void testDoubleToXport() {
        // The first four test cases are taken from TS-140.
        runDoubleToXportTest(1, new int[] { 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(-1, new int[] { 0xC1, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(0, new int[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(2, new int[] { 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });

        // Some other simple numbers
        runDoubleToXportTest(123.0, new int[] { 0x42, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(15.2, new int[] { 0x41, 0xF3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x30 });
        runDoubleToXportTest(-15.2, new int[] { 0xC1, 0xF3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x30 });

        // Test the full range of exponents
        runDoubleToXportTest(1.23456e-77, new int[] { 0x01, 0x16, 0xDF, 0x53, 0x51, 0x36, 0xBB, 0x08 });
        runDoubleToXportTest(1.23456e-76, new int[] { 0x01, 0xE4, 0xB9, 0x41, 0x2C, 0x23, 0x4E, 0x50 });
        runDoubleToXportTest(1.23456e-75, new int[] { 0x02, 0x8E, 0xF3, 0xC8, 0xBB, 0x96, 0x10, 0xF0 });
        runDoubleToXportTest(1.23456e-74, new int[] { 0x03, 0x59, 0x58, 0x5D, 0x75, 0x3D, 0xCA, 0x98 });
        runDoubleToXportTest(1.23456e-73, new int[] { 0x04, 0x37, 0xD7, 0x3A, 0x69, 0x46, 0x9E, 0x9E });
        runDoubleToXportTest(1.23456e-72, new int[] { 0x05, 0x22, 0xE6, 0x84, 0x81, 0xCC, 0x23, 0x24 });
        runDoubleToXportTest(1.23456e-71, new int[] { 0x06, 0x15, 0xD0, 0x12, 0xD1, 0x1F, 0x95, 0xF6 });
        runDoubleToXportTest(1.23456e-70, new int[] { 0x06, 0xDA, 0x20, 0xBC, 0x2B, 0x3B, 0xDB, 0x98 });
        runDoubleToXportTest(1.23456e-69, new int[] { 0x07, 0x88, 0x54, 0x75, 0x9B, 0x05, 0x69, 0x40 });
        runDoubleToXportTest(1.23456e-68, new int[] { 0x08, 0x55, 0x34, 0xC9, 0x80, 0xE3, 0x61, 0xC8 });
        runDoubleToXportTest(1.23456e-67, new int[] { 0x09, 0x35, 0x40, 0xFD, 0xF0, 0x8E, 0x1D, 0x1E });
        runDoubleToXportTest(1.23456e-66, new int[] { 0x0A, 0x21, 0x48, 0x9E, 0xB6, 0x58, 0xD2, 0x32 });
        runDoubleToXportTest(1.23456e-65, new int[] { 0x0B, 0x14, 0xCD, 0x63, 0x31, 0xF7, 0x83, 0x60 });
        runDoubleToXportTest(1.23456e-64, new int[] { 0x0B, 0xD0, 0x05, 0xDF, 0xF3, 0xAB, 0x21, 0xB8 });
        runDoubleToXportTest(1.23456e-63, new int[] { 0x0C, 0x82, 0x03, 0xAB, 0xF8, 0x4A, 0xF5, 0x18 });
        runDoubleToXportTest(1.23456e-62, new int[] { 0x0D, 0x51, 0x42, 0x4B, 0x7B, 0x2E, 0xD9, 0x2C });
        runDoubleToXportTest(1.23456e-61, new int[] { 0x0E, 0x32, 0xC9, 0x6F, 0x2C, 0xFD, 0x47, 0xBC });
        runDoubleToXportTest(1.23456e-60, new int[] { 0x0F, 0x1F, 0xBD, 0xE5, 0x7C, 0x1E, 0x4C, 0xD6 });
        runDoubleToXportTest(1.23456e-59, new int[] { 0x10, 0x13, 0xD6, 0xAF, 0x6D, 0x92, 0xF0, 0x06 });
        runDoubleToXportTest(1.23456e-58, new int[] { 0x10, 0xC6, 0x62, 0xDA, 0x47, 0xBD, 0x60, 0x38 });
        runDoubleToXportTest(1.23456e-57, new int[] { 0x11, 0x7B, 0xFD, 0xC8, 0x6C, 0xD6, 0x5C, 0x24 });
        runDoubleToXportTest(1.23456e-56, new int[] { 0x12, 0x4D, 0x7E, 0x9D, 0x44, 0x05, 0xF9, 0x94 });
        runDoubleToXportTest(1.23456e-55, new int[] { 0x13, 0x30, 0x6F, 0x22, 0x4A, 0x83, 0xBB, 0xFE });
        runDoubleToXportTest(1.23456e-54, new int[] { 0x14, 0x1E, 0x45, 0x75, 0x6E, 0x92, 0x55, 0x7E });
        runDoubleToXportTest(1.23456e-53, new int[] { 0x15, 0x12, 0xEB, 0x69, 0x65, 0x1B, 0x75, 0x6F });
        runDoubleToXportTest(1.23456e-52, new int[] { 0x15, 0xBD, 0x32, 0x1D, 0xF3, 0x12, 0x96, 0x58 });
        runDoubleToXportTest(1.23456e-51, new int[] { 0x16, 0x76, 0x3F, 0x52, 0xB7, 0xEB, 0x9D, 0xF4 });
        runDoubleToXportTest(1.23456e-50, new int[] { 0x17, 0x49, 0xE7, 0x93, 0xB2, 0xF3, 0x42, 0xB8 });
        runDoubleToXportTest(1.23456e-49, new int[] { 0x18, 0x2E, 0x30, 0xBC, 0x4F, 0xD8, 0x09, 0xB4 });
        runDoubleToXportTest(1.23456e-48, new int[] { 0x19, 0x1C, 0xDE, 0x75, 0xB1, 0xE7, 0x06, 0x11 });
        runDoubleToXportTest(1.23456e-47, new int[] { 0x1A, 0x12, 0x0B, 0x09, 0x8F, 0x30, 0x63, 0xCA });
        runDoubleToXportTest(1.23456e-46, new int[] { 0x1A, 0xB4, 0x6E, 0x5F, 0x97, 0xE3, 0xE5, 0xE8 });
        runDoubleToXportTest(1.23456e-45, new int[] { 0x1B, 0x70, 0xC4, 0xFB, 0xBE, 0xEE, 0x6F, 0xB0 });
        runDoubleToXportTest(1.23456e-44, new int[] { 0x1C, 0x46, 0x7B, 0x1D, 0x57, 0x55, 0x05, 0xD0 });
        runDoubleToXportTest(1.23456e-43, new int[] { 0x1D, 0x2C, 0x0C, 0xF2, 0x56, 0x95, 0x23, 0xA0 });
        runDoubleToXportTest(1.23456e-42, new int[] { 0x1E, 0x1B, 0x88, 0x17, 0x76, 0x1D, 0x36, 0x45 });
        runDoubleToXportTest(1.23456e-41, new int[] { 0x1F, 0x11, 0x35, 0x0E, 0xA9, 0xD2, 0x41, 0xEB });
        runDoubleToXportTest(1.23456e-40, new int[] { 0x1F, 0xAC, 0x12, 0x92, 0xA2, 0x36, 0x93, 0x30 });
        runDoubleToXportTest(1.23456e-39, new int[] { 0x20, 0x6B, 0x8B, 0x9B, 0xA5, 0x62, 0x1B, 0xFC });
        runDoubleToXportTest(1.23456e-38, new int[] { 0x21, 0x43, 0x37, 0x41, 0x47, 0x5D, 0x51, 0x7C });
        runDoubleToXportTest(1.23456e-37, new int[] { 0x22, 0x2A, 0x02, 0x88, 0xCC, 0x9A, 0x52, 0xEE });
        runDoubleToXportTest(1.23456e-36, new int[] { 0x23, 0x1A, 0x41, 0x95, 0x7F, 0xE0, 0x73, 0xD5 });
        runDoubleToXportTest(1.23456e-35, new int[] { 0x24, 0x10, 0x68, 0xFD, 0x6F, 0xEC, 0x48, 0x65 });
        runDoubleToXportTest(1.23456e-34, new int[] { 0x24, 0xA4, 0x19, 0xE6, 0x5F, 0x3A, 0xD3, 0xF0 });
        runDoubleToXportTest(1.23456e-33, new int[] { 0x25, 0x66, 0x90, 0x2F, 0xFB, 0x84, 0xC4, 0x78 });
        runDoubleToXportTest(1.23456e-32, new int[] { 0x26, 0x40, 0x1A, 0x1D, 0xFD, 0x32, 0xFA, 0xCC });
        runDoubleToXportTest(1.23456e-31, new int[] { 0x27, 0x28, 0x10, 0x52, 0xBE, 0x3F, 0xDC, 0xBE });
        runDoubleToXportTest(1.23456e-30, new int[] { 0x28, 0x19, 0x0A, 0x33, 0xB6, 0xE7, 0xE9, 0xF7 });
        runDoubleToXportTest(1.23456e-29, new int[] { 0x28, 0xFA, 0x66, 0x05, 0x25, 0x0F, 0x23, 0xA8 });
        runDoubleToXportTest(1.23456e-28, new int[] { 0x29, 0x9C, 0x7F, 0xC3, 0x37, 0x29, 0x76, 0x48 });
        runDoubleToXportTest(1.23456e-27, new int[] { 0x2A, 0x61, 0xCF, 0xDA, 0x02, 0x79, 0xE9, 0xF0 });
        runDoubleToXportTest(1.23456e-26, new int[] { 0x2B, 0x3D, 0x21, 0xE8, 0x41, 0x8C, 0x32, 0x34 });
        runDoubleToXportTest(1.23456e-25, new int[] { 0x2C, 0x26, 0x35, 0x31, 0x28, 0xF7, 0x9F, 0x62 });
        runDoubleToXportTest(1.23456e-24, new int[] { 0x2D, 0x17, 0xE1, 0x3E, 0xB9, 0x9A, 0xC3, 0x9D });
        runDoubleToXportTest(1.23456e-23, new int[] { 0x2D, 0xEE, 0xCC, 0x73, 0x40, 0x0B, 0xA4, 0x20 });
        runDoubleToXportTest(1.23456e-22, new int[] { 0x2E, 0x95, 0x3F, 0xC8, 0x08, 0x07, 0x46, 0x90 });
        runDoubleToXportTest(1.23456e-21, new int[] { 0x2F, 0x5D, 0x47, 0xDD, 0x05, 0x04, 0x8C, 0x1C });
        runDoubleToXportTest(1.23456e-20, new int[] { 0x30, 0x3A, 0x4C, 0xEA, 0x23, 0x22, 0xD7, 0x92 });
        runDoubleToXportTest(1.23456e-19, new int[] { 0x31, 0x24, 0x70, 0x12, 0x55, 0xF5, 0xC6, 0xBA });
        runDoubleToXportTest(1.23456e-18, new int[] { 0x32, 0x16, 0xC6, 0x0B, 0x75, 0xB9, 0x9C, 0x35 });
        runDoubleToXportTest(1.23456e-17, new int[] { 0x32, 0xE3, 0xBC, 0x72, 0x99, 0x40, 0x1A, 0x10 });
        runDoubleToXportTest(1.23456e-16, new int[] { 0x33, 0x8E, 0x55, 0xC7, 0x9F, 0xC8, 0x10, 0x48 });
        runDoubleToXportTest(1.23456e-15, new int[] { 0x34, 0x58, 0xF5, 0x9C, 0xC3, 0xDD, 0x0A, 0x30 });
        runDoubleToXportTest(1.23456e-14, new int[] { 0x35, 0x37, 0x99, 0x81, 0xFA, 0x6A, 0x26, 0x5C });
        runDoubleToXportTest(1.23456e-13, new int[] { 0x36, 0x22, 0xBF, 0xF1, 0x3C, 0x82, 0x57, 0xFA });
        runDoubleToXportTest(1.23456e-12, new int[] { 0x37, 0x15, 0xB7, 0xF6, 0xC5, 0xD1, 0x76, 0xFC });
        runDoubleToXportTest(1.23456e-11, new int[] { 0x37, 0xD9, 0x2F, 0xA3, 0xBA, 0x2E, 0xA5, 0xD8 });
        runDoubleToXportTest(1.23456e-10, new int[] { 0x38, 0x87, 0xBD, 0xC6, 0x54, 0x5D, 0x27, 0xA8 });
        runDoubleToXportTest(1.23456e-09, new int[] { 0x39, 0x54, 0xD6, 0x9B, 0xF4, 0xBA, 0x38, 0xC8 });
        runDoubleToXportTest(1.23456e-08, new int[] { 0x3A, 0x35, 0x06, 0x21, 0x78, 0xF4, 0x63, 0x7E });
        runDoubleToXportTest(1.23456e-07, new int[] { 0x3B, 0x21, 0x23, 0xD4, 0xEB, 0x98, 0xBE, 0x2E });
        runDoubleToXportTest(1.23456e-06, new int[] { 0x3C, 0x14, 0xB6, 0x65, 0x13, 0x3F, 0x76, 0xDD });
        runDoubleToXportTest(1.23456e-05, new int[] { 0x3C, 0xCF, 0x1F, 0xF2, 0xC0, 0x7A, 0xA4, 0xA0 });
        runDoubleToXportTest(1.23456e-04, new int[] { 0x3D, 0x81, 0x73, 0xF7, 0xB8, 0x4C, 0xA6, 0xE8 });
        runDoubleToXportTest(1.23456e-03, new int[] { 0x3E, 0x50, 0xE8, 0x7A, 0xD3, 0x2F, 0xE8, 0x50 });
        runDoubleToXportTest(1.23456e-02, new int[] { 0x3F, 0x32, 0x91, 0x4C, 0xC3, 0xFD, 0xF1, 0x32 });
        runDoubleToXportTest(1.23456e-01, new int[] { 0x40, 0x1F, 0x9A, 0xCF, 0xFA, 0x7E, 0xB6, 0xBF });
        runDoubleToXportTest(1.23456e+00, new int[] { 0x41, 0x13, 0xC0, 0xC1, 0xFC, 0x8F, 0x32, 0x38 });
        runDoubleToXportTest(1.23456e+01, new int[] { 0x41, 0xC5, 0x87, 0x93, 0xDD, 0x97, 0xF6, 0x28 });
        runDoubleToXportTest(1.23456e+02, new int[] { 0x42, 0x7B, 0x74, 0xBC, 0x6A, 0x7E, 0xF9, 0xDC });
        runDoubleToXportTest(1.23456e+03, new int[] { 0x43, 0x4D, 0x28, 0xF5, 0xC2, 0x8F, 0x5C, 0x28 });
        runDoubleToXportTest(1.23456e+04, new int[] { 0x44, 0x30, 0x39, 0x99, 0x99, 0x99, 0x99, 0x9A });
        runDoubleToXportTest(1.23456e+05, new int[] { 0x45, 0x1E, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+06, new int[] { 0x46, 0x12, 0xD6, 0x80, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+07, new int[] { 0x46, 0xBC, 0x61, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+08, new int[] { 0x47, 0x75, 0xBC, 0xA0, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+09, new int[] { 0x48, 0x49, 0x95, 0xE4, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+10, new int[] { 0x49, 0x2D, 0xFD, 0xAE, 0x80, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+11, new int[] { 0x4A, 0x1C, 0xBE, 0x8D, 0x10, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+12, new int[] { 0x4B, 0x11, 0xF7, 0x18, 0x2A, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+13, new int[] { 0x4B, 0xB3, 0xA6, 0xF1, 0xA4, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+14, new int[] { 0x4C, 0x70, 0x48, 0x57, 0x06, 0x80, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+15, new int[] { 0x4D, 0x46, 0x2D, 0x36, 0x64, 0x10, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+16, new int[] { 0x4E, 0x2B, 0xDC, 0x41, 0xFE, 0x8A, 0x00, 0x00 });
        runDoubleToXportTest(1.23456e+17, new int[] { 0x4F, 0x1B, 0x69, 0xA9, 0x3F, 0x16, 0x40, 0x00 });
        runDoubleToXportTest(1.23456e+18, new int[] { 0x50, 0x11, 0x22, 0x09, 0xC7, 0x6D, 0xE8, 0x00 });
        runDoubleToXportTest(1.23456e+19, new int[] { 0x50, 0xAB, 0x54, 0x61, 0xCA, 0x4B, 0x10, 0x00 });
        runDoubleToXportTest(1.23456e+20, new int[] { 0x51, 0x6B, 0x14, 0xBD, 0x1E, 0x6E, 0xEA, 0x00 });
        runDoubleToXportTest(1.23456e+21, new int[] { 0x52, 0x42, 0xEC, 0xF6, 0x33, 0x05, 0x52, 0x40 });
        runDoubleToXportTest(1.23456e+22, new int[] { 0x53, 0x29, 0xD4, 0x19, 0xDF, 0xE3, 0x53, 0x68 });
        runDoubleToXportTest(1.23456e+23, new int[] { 0x54, 0x1A, 0x24, 0x90, 0x2B, 0xEE, 0x14, 0x21 });
        runDoubleToXportTest(1.23456e+24, new int[] { 0x55, 0x10, 0x56, 0xDA, 0x1B, 0x74, 0xCC, 0x95 });
        runDoubleToXportTest(1.23456e+25, new int[] { 0x55, 0xA3, 0x64, 0x85, 0x12, 0x8F, 0xFD, 0xD0 });
        runDoubleToXportTest(1.23456e+26, new int[] { 0x56, 0x66, 0x1E, 0xD3, 0x2B, 0x99, 0xFE, 0xA0 });
        runDoubleToXportTest(1.23456e+27, new int[] { 0x57, 0x3F, 0xD3, 0x43, 0xFB, 0x40, 0x3F, 0x24 });
        runDoubleToXportTest(1.23456e+28, new int[] { 0x58, 0x27, 0xE4, 0x0A, 0x7D, 0x08, 0x27, 0x76 });
        runDoubleToXportTest(1.23456e+29, new int[] { 0x59, 0x18, 0xEE, 0x86, 0x8E, 0x25, 0x18, 0xAA });
        runDoubleToXportTest(1.23456e+30, new int[] { 0x59, 0xF9, 0x51, 0x41, 0x8D, 0x72, 0xF6, 0xA8 });
        runDoubleToXportTest(1.23456e+31, new int[] { 0x5A, 0x9B, 0xD2, 0xC8, 0xF8, 0x67, 0xDA, 0x28 });
        runDoubleToXportTest(1.23456e+32, new int[] { 0x5B, 0x61, 0x63, 0xBD, 0x9B, 0x40, 0xE8, 0x58 });
        runDoubleToXportTest(1.23456e+33, new int[] { 0x5C, 0x3C, 0xDE, 0x56, 0x81, 0x08, 0x91, 0x38 });
        runDoubleToXportTest(1.23456e+34, new int[] { 0x5D, 0x26, 0x0A, 0xF6, 0x10, 0xA5, 0x5A, 0xC2 });
        runDoubleToXportTest(1.23456e+35, new int[] { 0x5E, 0x17, 0xC6, 0xD9, 0xCA, 0x67, 0x58, 0xBA });
        runDoubleToXportTest(1.23456e+36, new int[] { 0x5E, 0xED, 0xC4, 0x81, 0xE8, 0x09, 0x77, 0x40 });
        runDoubleToXportTest(1.23456e+37, new int[] { 0x5F, 0x94, 0x9A, 0xD1, 0x31, 0x05, 0xEA, 0x88 });
        runDoubleToXportTest(1.23456e+38, new int[] { 0x60, 0x5C, 0xE0, 0xC2, 0xBE, 0xA3, 0xB2, 0x94 });
        runDoubleToXportTest(1.23456e+39, new int[] { 0x61, 0x3A, 0x0C, 0x79, 0xB7, 0x26, 0x4F, 0x9E });
        runDoubleToXportTest(1.23456e+40, new int[] { 0x62, 0x24, 0x47, 0xCC, 0x12, 0x77, 0xF1, 0xC2 });
        runDoubleToXportTest(1.23456e+41, new int[] { 0x63, 0x16, 0xAC, 0xDF, 0x8B, 0x8A, 0xF7, 0x1A });
        runDoubleToXportTest(1.23456e+42, new int[] { 0x63, 0xE2, 0xC0, 0xBB, 0x73, 0x6D, 0xA7, 0x00 });
        runDoubleToXportTest(1.23456e+43, new int[] { 0x64, 0x8D, 0xB8, 0x75, 0x28, 0x24, 0x88, 0x60 });
        runDoubleToXportTest(1.23456e+44, new int[] { 0x65, 0x58, 0x93, 0x49, 0x39, 0x16, 0xD5, 0x3C });
        runDoubleToXportTest(1.23456e+45, new int[] { 0x66, 0x37, 0x5C, 0x0D, 0xC3, 0xAE, 0x45, 0x46 });
        runDoubleToXportTest(1.23456e+46, new int[] { 0x67, 0x22, 0x99, 0x88, 0x9A, 0x4C, 0xEB, 0x4C });
        runDoubleToXportTest(1.23456e+47, new int[] { 0x68, 0x15, 0x9F, 0xF5, 0x60, 0x70, 0x13, 0x0F });
        runDoubleToXportTest(1.23456e+48, new int[] { 0x68, 0xD8, 0x3F, 0x95, 0xC4, 0x60, 0xBE, 0x98 });
        runDoubleToXportTest(1.23456e+49, new int[] { 0x69, 0x87, 0x27, 0xBD, 0x9A, 0xBC, 0x77, 0x20 });
        runDoubleToXportTest(1.23456e+50, new int[] { 0x6A, 0x54, 0x78, 0xD6, 0x80, 0xB5, 0xCA, 0x74 });
        runDoubleToXportTest(1.23456e+51, new int[] { 0x6B, 0x34, 0xCB, 0x86, 0x10, 0x71, 0x9E, 0x88 });
        runDoubleToXportTest(1.23456e+52, new int[] { 0x6C, 0x20, 0xFF, 0x33, 0xCA, 0x47, 0x03, 0x14 });
        runDoubleToXportTest(1.23456e+53, new int[] { 0x6D, 0x14, 0x9F, 0x80, 0x5E, 0x6C, 0x61, 0xED });
        runDoubleToXportTest(1.23456e+54, new int[] { 0x6D, 0xCE, 0x3B, 0x03, 0xB0, 0x3B, 0xD3, 0x40 });
        runDoubleToXportTest(1.23456e+55, new int[] { 0x6E, 0x80, 0xE4, 0xE2, 0x4E, 0x25, 0x64, 0x08 });
        runDoubleToXportTest(1.23456e+56, new int[] { 0x6F, 0x50, 0x8F, 0x0D, 0x70, 0xD7, 0x5E, 0x88 });
        runDoubleToXportTest(1.23456e+57, new int[] { 0x70, 0x32, 0x59, 0x68, 0x66, 0x86, 0x9B, 0x14 });
        runDoubleToXportTest(1.23456e+58, new int[] { 0x71, 0x1F, 0x77, 0xE1, 0x40, 0x14, 0x20, 0xEC });
        runDoubleToXportTest(1.23456e+59, new int[] { 0x72, 0x13, 0xAA, 0xEC, 0xC8, 0x0C, 0x94, 0x94 });
        runDoubleToXportTest(1.23456e+60, new int[] { 0x72, 0xC4, 0xAD, 0x3F, 0xD0, 0x7D, 0xCD, 0xC8 });
        runDoubleToXportTest(1.23456e+61, new int[] { 0x73, 0x7A, 0xEC, 0x47, 0xE2, 0x4E, 0xA0, 0x9C });
        runDoubleToXportTest(1.23456e+62, new int[] { 0x74, 0x4C, 0xD3, 0xAC, 0xED, 0x71, 0x24, 0x60 });
        runDoubleToXportTest(1.23456e+63, new int[] { 0x75, 0x30, 0x04, 0x4C, 0x14, 0x66, 0xB6, 0xBC });
        runDoubleToXportTest(1.23456e+64, new int[] { 0x76, 0x1E, 0x02, 0xAF, 0x8C, 0xC0, 0x32, 0x36 });
        runDoubleToXportTest(1.23456e+65, new int[] { 0x77, 0x12, 0xC1, 0xAD, 0xB7, 0xF8, 0x1F, 0x62 });
        runDoubleToXportTest(1.23456e+66, new int[] { 0x77, 0xBB, 0x90, 0xC9, 0x2F, 0xB1, 0x39, 0xD0 });
        runDoubleToXportTest(1.23456e+67, new int[] { 0x78, 0x75, 0x3A, 0x7D, 0xBD, 0xCE, 0xC4, 0x24 });
        runDoubleToXportTest(1.23456e+68, new int[] { 0x79, 0x49, 0x44, 0x8E, 0x96, 0xA1, 0x3A, 0x94 });
        runDoubleToXportTest(1.23456e+69, new int[] { 0x7A, 0x2D, 0xCA, 0xD9, 0x1E, 0x24, 0xC4, 0x9E });
        runDoubleToXportTest(1.23456e+70, new int[] { 0x7B, 0x1C, 0x9E, 0xC7, 0xB2, 0xD6, 0xFA, 0xE2 });
        runDoubleToXportTest(1.23456e+71, new int[] { 0x7C, 0x11, 0xE3, 0x3C, 0xCF, 0xC6, 0x5C, 0xCE });
        runDoubleToXportTest(1.23456e+72, new int[] { 0x7C, 0xB2, 0xE0, 0x60, 0x1D, 0xBF, 0xA0, 0x08 });
        runDoubleToXportTest(1.23456e+73, new int[] { 0x7D, 0x6F, 0xCC, 0x3C, 0x12, 0x97, 0xC4, 0x04 });
        runDoubleToXportTest(1.23456e+74, new int[] { 0x7E, 0x45, 0xDF, 0xA5, 0x8B, 0x9E, 0xDA, 0x84 });
    }

    @Test
    public void testDoubleToXportOutOfRange() {
        // Slightly larger than the smallest representable number
        runDoubleToXportTest(5.397605346934029E-79, new int[] { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 });

        // The smallest representable number
        runDoubleToXportTest(5.397605346934028E-79, new int[] { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });

        // Slightly smaller than the smallest representable number
        runIllegalArgumentDoubleToXportTest(5.397605346934000E-79,
            "XPORT format cannot store numbers smaller than pow(2, -260)");

        // Much smaller than the smallest representable number
        runIllegalArgumentDoubleToXportTest(1E-80, "XPORT format cannot store numbers smaller than pow(2, -260)");

        // Same tests as above but with negative values.
        // Slightly larger than the smallest representable number
        runDoubleToXportTest(-5.397605346934029E-79, new int[] { 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 });
        runDoubleToXportTest(-5.397605346934028E-79, new int[] { 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runIllegalArgumentDoubleToXportTest(-5.397605346934000E-79,
            "XPORT format cannot store numbers smaller than pow(2, -260)");
        runIllegalArgumentDoubleToXportTest(01E-80, "XPORT format cannot store numbers smaller than pow(2, -260)");

        // Slightly smaller than the largest representable number
        runDoubleToXportTest(9.0462569716653260E+74, new int[] { 0x7F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE });

        // The largest representable number
        runDoubleToXportTest(9.0462569716653265E+74, new int[] { 0x7F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });

        // Slightly larger than the largest representable number
        // For this value, %loc2xpt writes 0x7f20000000000000, but this wrong, as this represents a *smaller*
        // number than the largest maximum (9.046256971665328e+74).
        runIllegalArgumentDoubleToXportTest(9.0462569716653280E+74,
            "XPORT format cannot store numbers larger than pow(2, 248)");

        // Much larger than the largest representable number
        // For this value, %loc2xpt writes 0x7f235fadd81c2822, which is way off.
        runIllegalArgumentDoubleToXportTest(1E+75, "XPORT format cannot store numbers larger than pow(2, 248)");

        // Same tests as above but with negative values.
        runDoubleToXportTest(-9.0462569716653260E+74, new int[] { 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE });
        runDoubleToXportTest(-9.0462569716653265E+74, new int[] { 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });
        runIllegalArgumentDoubleToXportTest(-9.0462569716653280E+74,
            "XPORT format cannot store numbers larger than pow(2, 248)");
        runIllegalArgumentDoubleToXportTest(1E+75, "XPORT format cannot store numbers larger than pow(2, 248)");

        //
        // Special Java cases are all out of range
        //
        runIllegalArgumentDoubleToXportTest(Double.MAX_VALUE,
            "XPORT format cannot store numbers larger than pow(2, 248)");
        runIllegalArgumentDoubleToXportTest(-Double.MAX_VALUE,
            "XPORT format cannot store numbers larger than pow(2, 248)");

        runIllegalArgumentDoubleToXportTest(Double.MIN_NORMAL,
            "XPORT format cannot store numbers smaller than pow(2, -260)");
        runIllegalArgumentDoubleToXportTest(-Double.MIN_NORMAL,
            "XPORT format cannot store numbers smaller than pow(2, -260)");

        runIllegalArgumentDoubleToXportTest(Double.NEGATIVE_INFINITY,
            "XPORT format cannot store numbers larger than pow(2, 248)");
        runIllegalArgumentDoubleToXportTest(Double.POSITIVE_INFINITY,
            "XPORT format cannot store numbers larger than pow(2, 248)");

        runIllegalArgumentDoubleToXportTest(Double.NaN, "XPORT format has no representation for NaN");
        runIllegalArgumentDoubleToXportTest(-Double.NaN, "XPORT format has no representation for NaN");
        runIllegalArgumentDoubleToXportTest(Double.longBitsToDouble(0x7FF0000000000001L),
            "XPORT format has no representation for NaN");
        runIllegalArgumentDoubleToXportTest(Double.longBitsToDouble(0xFFF0000000000001L),
            "XPORT format has no representation for NaN");
        runIllegalArgumentDoubleToXportTest(Double.longBitsToDouble(0xFFF0000000200000L),
            "XPORT format has no representation for NaN");

        // Make sure that the public MIN/MAX values correspond to the real min/max values.
        runDoubleToXportTest(SasTransportExporter.MIN_VALUE,
            new int[] { 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(-SasTransportExporter.MIN_VALUE,
            new int[] { 0x80, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 });
        runDoubleToXportTest(SasTransportExporter.MAX_VALUE,
            new int[] { 0x7F, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });
        runDoubleToXportTest(-SasTransportExporter.MAX_VALUE,
            new int[] { 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF });
    }

    private static void runXportToDoubleTest(byte[] xport, double expectedNumber) {
        Object actualNumber = DoubleConverter.xportToDouble(xport);

        // Check the result.
        assertInstanceOf(Double.class, actualNumber, "xportToDouble() did not return a Double");
        assertEquals(Double.valueOf(expectedNumber), Double.valueOf((Double) actualNumber));
    }

    private static void runXportToDoubleTest(byte[] xport, MissingValue expectedMissingValue) {
        Object actualReturnValue = DoubleConverter.xportToDouble(xport);
        assertEquals(expectedMissingValue, actualReturnValue);
    }

    private static void runIllegalArgumentXportToDoubleTest(byte[] xport, String expectedMessage) {
        Exception exception = assertThrows(//
            IllegalArgumentException.class, //
            () -> DoubleConverter.xportToDouble(xport), //
            "Running xportToDouble with illegal argument");
        assertEquals(expectedMessage, exception.getMessage());
    }

    @Test
    public void testXportToDouble() {
        // The first four test cases are taken from TS-140.
        runXportToDoubleTest(new byte[] { 0x41, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 1.0);
        runXportToDoubleTest(new byte[] { (byte) 0xC1, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, -1);
        runXportToDoubleTest(new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 0.0);
        runXportToDoubleTest(new byte[] { 0x41, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 2.0);

        // Other test cases
        runXportToDoubleTest(new byte[] { 0x42, 0x7B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, 123.0);
        runXportToDoubleTest(new byte[] { 0x41, (byte) 0xF3, 0x33, 0x33, 0x33, 0x33, 0x33, 0x30 }, 15.2);

        // Bad input test cases
        runIllegalArgumentXportToDoubleTest(//
            new byte[] { 'A' - 1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // missing value < .A
            "mantissa is zero but value is not 0 or a MissingValue");

        runIllegalArgumentXportToDoubleTest(//
            new byte[] { 'Z' + 1, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // missing value > .Z
            "mantissa is zero but value is not 0 or a MissingValue");

        runIllegalArgumentXportToDoubleTest(//
            new byte[] { 'a', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // missing value < .a
            "mantissa is zero but value is not 0 or a MissingValue");

        runIllegalArgumentXportToDoubleTest(//
            new byte[] { 'z', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, // missing value < .z
            "mantissa is zero but value is not 0 or a MissingValue");
    }

    @Test
    public void testXportToDoubleMissingValue() {
        runXportToDoubleTest(new byte[] { '.', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.STANDARD);
        runXportToDoubleTest(new byte[] { '_', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.UNDERSCORE);
        runXportToDoubleTest(new byte[] { 'A', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.A);
        runXportToDoubleTest(new byte[] { 'B', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.B);
        runXportToDoubleTest(new byte[] { 'C', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.C);
        runXportToDoubleTest(new byte[] { 'D', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.D);
        runXportToDoubleTest(new byte[] { 'E', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.E);
        runXportToDoubleTest(new byte[] { 'F', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.F);
        runXportToDoubleTest(new byte[] { 'G', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.G);
        runXportToDoubleTest(new byte[] { 'H', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.H);
        runXportToDoubleTest(new byte[] { 'I', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.I);
        runXportToDoubleTest(new byte[] { 'J', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.J);
        runXportToDoubleTest(new byte[] { 'K', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.K);
        runXportToDoubleTest(new byte[] { 'L', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.L);
        runXportToDoubleTest(new byte[] { 'M', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.M);
        runXportToDoubleTest(new byte[] { 'N', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.N);
        runXportToDoubleTest(new byte[] { 'O', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.O);
        runXportToDoubleTest(new byte[] { 'P', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.P);
        runXportToDoubleTest(new byte[] { 'Q', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.Q);
        runXportToDoubleTest(new byte[] { 'R', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.R);
        runXportToDoubleTest(new byte[] { 'S', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.S);
        runXportToDoubleTest(new byte[] { 'T', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.T);
        runXportToDoubleTest(new byte[] { 'U', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.U);
        runXportToDoubleTest(new byte[] { 'V', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.V);
        runXportToDoubleTest(new byte[] { 'W', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.W);
        runXportToDoubleTest(new byte[] { 'X', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.X);
        runXportToDoubleTest(new byte[] { 'Y', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.Y);
        runXportToDoubleTest(new byte[] { 'Z', 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }, MissingValue.Z);
    }

    /**
     * Does a round trip from Java -> XPORT -> Java and fails the test if the end result is not identical to the
     * starting value.
     *
     * @param number
     *     The number of convert and test.
     */
    private void runRoundTripTest(double number) {

        // Java -> XPORT
        byte[] xport = DoubleConverter.doubleToXport(number);

        // XPORT -> Java
        Object returnNumber = DoubleConverter.xportToDouble(xport);

        // Check the result.
        assertInstanceOf(Double.class, returnNumber, "Round trip for " + number + " did not return a Double");
        assertEquals(Double.valueOf(number), Double.valueOf((Double) returnNumber), "Round trip for " + number);
    }

    /**
     * Tests that {@link DoubleConverter#doubleToXport} and {@link DoubleConverter#xportToDouble} are inverse functions
     * for a limited domain. This is redundant with the tests specific to those methods but is easier to read.
     */
    @Test
    public void testDoubleToXportToDouble() {
        runRoundTripTest(0);
        runRoundTripTest(1.23456);
        runRoundTripTest(1.23456E10);
        runRoundTripTest(1.23456E-1);
        runRoundTripTest(1.23456E-2);
        runRoundTripTest(1.23456E-10);
        runRoundTripTest(1.23456E-70);
        runRoundTripTest(1.23456E40);
        runRoundTripTest(1.23456E60);
        runRoundTripTest(1.23456E70);
    }
}